namespace DeriSock.DevTools.CodeDom;

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Threading.Tasks;

using DeriSock.DevTools.ApiDoc.Model;

using Microsoft.CSharp;

internal class ApiDocumentationCodeProvider
{
  public string Namespace { get; set; } = "DeriSock.Model";

  public async Task GenerateMethodParametersAsync(Stream stream, string methodName, Method method)
  {
    if (method.Params is null)
      return;

    var codeEntity = new CodeTypeDeclaration(string.Concat(methodName, "/Parameters").Split('/').ToPublicCodeName())
    {
      Attributes = MemberAttributes.Public
    };

    codeEntity.CustomAttributes.Add(new CodeAttributeDeclaration("System.Diagnostics.DebuggerNonUserCodeAttribute"));

    if (method.Deprecated.HasValue && method.Deprecated.Value)
      codeEntity.CustomAttributes.Add(new CodeAttributeDeclaration("System.ObsoleteAttribute"));

    foreach (var (methodParamName, methodParam) in method.Params)
      codeEntity.Members.AddProperty(methodParamName, methodParam.GetManagedTypeInfo(), methodParamName.ToPublicCodeName(), methodParam.Description, false);

    var compileNamespace = new CodeNamespace(Namespace);

    //compileNamespace.Imports.Add(new CodeNamespaceImport("DeriSock.Utils"));
    compileNamespace.Types.Add(codeEntity);

    var compileUnit = new CodeCompileUnit();
    compileUnit.Namespaces.Add(compileNamespace);

    await GenerateCodeFromCompileUnitAsync(stream, compileUnit);
  }

  public async Task GenerateMethodResponseAsync(Stream stream, string methodName, Method method)
  {
    if (stream == null)
      throw new ArgumentNullException(nameof(stream));

    if (methodName == null)
      throw new ArgumentNullException(nameof(methodName));

    if (method == null)
      throw new ArgumentNullException(nameof(method));

    if (method.Response is null)
      return;

    if (method.Response.IsComplex && method.Response.ObjectParams is null)
      return;

    var codeEntity = new CodeTypeDeclaration(method.Response.ManagedType?.Name ?? string.Concat(methodName, "/Result").Split('/').ToPublicCodeName())
    {
      Attributes = MemberAttributes.Public
    };

    codeEntity.Members.Add(new CodeSnippetTypeMember("#nullable enable"));

    codeEntity.CustomAttributes.Add(new CodeAttributeDeclaration("System.Diagnostics.DebuggerNonUserCodeAttribute"));

    if (method.Deprecated.HasValue && method.Deprecated.Value)
      codeEntity.CustomAttributes.Add(new CodeAttributeDeclaration("System.ObsoleteAttribute"));

    if (method.Response.IsComplex)
    {
      foreach (var (responseParamName, responseParam) in method.Response.ObjectParams!)
      {
        codeEntity.Members.AddProperty(responseParamName, responseParam.GetManagedTypeInfo(), responseParamName.ToPublicCodeName(), responseParam.Description, responseParam.Deprecated);
      }
    }
    else {
      codeEntity.Members.AddProperty("result", method.Response.GetManagedTypeInfo(), "Value", method.Response.Description, false);
    }
    
    var compileNamespace = new CodeNamespace(Namespace);
    
    //compileNamespace.Imports.Add(new CodeNamespaceImport("DeriSock.Utils"));
    compileNamespace.Types.Add(codeEntity);

    var compileUnit = new CodeCompileUnit();
    compileUnit.Namespaces.Add(compileNamespace);

    //await GenerateCodeFromCompileUnitAsync(stream, new CodeSnippetCompileUnit("// <auto-generated/>\r\n#nullable enable"));
    await GenerateCodeFromCompileUnitAsync(stream, compileUnit);
  }

  private async Task GenerateCodeFromCompileUnitAsync(Stream stream, CodeCompileUnit compileUnit)
  {
    var provider = new CSharpCodeProvider();
    var writer = new StreamWriter(stream, leaveOpen: true);

    var options = new CodeGeneratorOptions
    {
      IndentString = "  ",
      BlankLinesBetweenMembers = false,
      BracingStyle = "",
      VerbatimOrder = true
    };

    provider.GenerateCodeFromCompileUnit(compileUnit, writer, options);
    await writer.FlushAsync();
  }
}
